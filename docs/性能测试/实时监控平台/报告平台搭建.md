# 引子
声音可以听到吗？请大家帮忙确认下

大家好，很高兴能同学们来参加咱们霍格沃兹测试开发学社的的训练营。

提醒大家关注视频号

# 目录

那我们今天的课程是如何安排的呢？下面我们来看一下目录。

- 开营仪式
- 环境准备
- 实战练习
- 总结



咱们今天的课程会分为下面的几个部分。

我们今天是三天训练营的第一次直播，所以我们今天 首先是一个简短的开营仪式，我们会介绍一下开为什么要开设这个训练营，同学们如何在训练营中快乐的学习。

然后呢，我们会介绍一下咱们参加咱们训练营要提前准备的环境有哪些。如何验证环境是否安装成功。
 
然后我们就会进入到实战练习的环节。

每一天课程的最后，都会给大家简单总结学习了哪些知识点。

这就是我们今天课程的安排。我们的直播差不多是一个小时多点的时间。

## 开营仪式

首先呢，我们简短的先来进行开营仪式。

说是仪式，其实就是想给大家介绍一下参加咱们训练营的一个学习方法。让大家在这 3 天里能有更大的收获。

## 讲师介绍

首先呢，先来简单的自我介绍一下。

听过Java班测开的同学应该还是比较熟悉我的。 

那我们为什么要开设这次训练营呢？

## 学习问题

其实呢，也是因为收到了很多同学的反馈，因为很多同学在学习的过程中遇到了一些问题。

比如说。

碎片化时间较多，完整学习时间较少。
刚学习到的知识很容易忘。
如果学习过程中没有正向反馈，容易放弃。
不了解自己的学习效果，学习之后到底掌握了多少。
学习之后不知道如何面试。


那为了让大家能更高效的学习，比如说我们拿出3天晚上的1个多小时的时间，能熟练的掌握一个小的技术点，这样也能让大家有个阶段性的进步。最主要的是能把技术掌握扎实，能看到自己学习的效果。

所以我们今年预备给大家开一系列的训练营的课程。

咱们今年的训练营是精心设计过的。训练营其实就相当于咱们测开大课、性能大课的一个微缩版。

## 结合 PDCA 法则科学设计训练营

|     | 英文名称 | 含义 | 训练营                             |
| --- | -------- | ---- | ---------------------------------- |
| P   | Plan     | 计划 | 学习计划                           |
| D   | Do       | 执行 | 录播与直播学习、群内答疑、远程服务 |
| C   | Check    | 检查 | 作业检查学习内容                   |
| A   | Act      | 处理 | 作业讲解与面试题总结               |

整个训练营其实就是咱们大课的一个微缩版。

学社设计课程的主要从两点出发

**匹配行业需求**：之前看到很多同学在学习的过程中，学习了很多其实已经是在行业内落后的课程内容，比如 **QTP** 或者和测试并没有什么直接关系的课程，比如**爬虫**。如果投入大量的时间在这些课程里面，那反而会让我们忽略真正的需求。教给大家都是行业内真正需要的技术。
 


**提升学习效果**：在学习的过程中，我们收到了很多同学提出来很影响他们学习的一些问题：
大部分人一周最多有一次超出3小时以上的完整时间学习。碎片化时间较多，通勤、午休、厕所。

 
如果学习过程中没有正向反馈，容易放弃。比如很典型的就是环境问题，很多人在刚开始学习的时候，配环境就得配一天。

刚学习到的知识很容易忘。

不了解自己的学习效果，学习之后到底掌握了多少。

那怎样才能解决上面提到的问题呢，其实就是对症下药。

而这些问题，其实就和治病一样，吃对药，自然药到病除。

反之，如果没有好的学习方式和目标，则会起到相反的效果。

**如何可以提升学习效果呢**？

其实有两个点：

有明确的**学习目标**和**规划**。

尽可能**提升**自己在**单位时间内的学习效率**。

时刻**自检自己的学习效果**。


**学院的整套课程体系都是满足这个需求的：**

在课程大纲的设计过程中，

1. 在**内容选择上面**，完全匹配到目前企业所有的需求。而且会根据技术栈的更迭，去更新我们自己的课程内容，

    比如在 23期，我们增加了**中间件**的专题课知识、以及应学员的需求，我们也更新了时下比较主流的S**DK测试**、**人工智能**、**大数据测试**，**如何通过ChatGPT结合测试**，提升我们的测试效率。


1. **循序渐进**：如果一开始直接学习一块比较难的知识内容，对于一个新手来说是非常痛苦的，就像你刚从新手村出身，就要你去挑战boss一样。

    所以为了解决大家这块的学习问题。我们的课程设计了从L1~L5的循序渐进的过程。

    L1对应初级、L2 对应中级、L3对应高级、L4对应资深、L5对应专家，每一个知识模块，都有对应的级别，大家可以对比一下我们的课程大纲，看一下自己目前处于哪个级别。


1. **实战与理论结合**： 每个阶段都有一次实战，将前面所学知识融合，既可以复习旧的知识，也通过实战，了解到该技术具体的应用落地。

1. **作业与考试**： 每个阶段的知识提供作业，根据作业的完成分数，了解自己的掌握情况，从而弥补不足之处。


如果在**学习的过程**中，出现了任何的学习问题，尽量能在很短的时间内，快速解决。

有一个好的学习氛围，能够坚持学习，**班级群**每天会有同学讨论问题，班主任会**1v1**关注你的学习情况进行督学。

当然了，学习的最终目的是能够换一个好的工作。所以在这块我们也为大家提供了相应的完整的服务。从**简历指导，面试题库， 到企业内推**，也是为大家提供了更好的一个找工作的环境。

大家其实也会有感受，就是自己自学的时候，效率也低，也不知道自己掌握的怎么样。

所以呢，我们就按照大课的模式，也就是 PDCA 的法则设计了这一系列的训练营。

我们训练营也是根据这个规则去设计的，如果还没有进班级群的同学，可以扫**码右上角的二维码去扫描一下进群**。

所谓PDCA，即是 **计划(Plan)、实施(Do)、检查(Check)、处理(Act)** 的首字母组合。无论哪一项工作都离不开PDCA的循环，每一项工作都需要经过计划、执行计划、检查计划、对计划进行调整并不断改善这样四个阶段。

也就是说，我们在学习之前要先做好计划。

然后就按照计划的节奏进行学习。

学习过程中就包括了提前预习咱们的环境准备的录播视频，然后按时参加我们三天晚上的直播课程。

在学习的过程中，如果遇到问题，可以及时在群里向助教老师提问。尤其是环境配置类的问题。好多同学开始学习的时候，就被卡在了环境搭建的第一步。

其实是要迈过了这个坎，后面的学习就会很顺利了。

那上完课之后，怎么知道我们学会了没有呢？

这个时候就会通过课后的作业来检验大家的学习效果了。

而且也会有班主任老师一直陪着大家，督促大家好好学习，让整个学习的氛围更好。

写作业的过程中遇到问题也可以及时向助教老师提问的哈。如果有实在解决不了的问题我们的助教老师也可以提供远程服务的。

最后，大家的作业写的怎么样呢？作业完成的思路是什么样的呢？我们也会在第二天的直播中给大家进行分析和讲解。




这样一站式的课程体系，就可以让大家很好掌握这些知识和技术了。

这就是我们按照大课的模式给大家设计的训练营。希望大家通过这 3 天的学习，能够完成我们的学习目标，扎实的掌握技能，完成自己的成长和蜕变哈。

## 开营目标

- 夯实性能工具应用 - JMeter基础使用
- 熟悉性能测试工程师核心技能 - 监控平台
- 体验 VIP 服务，短时聚焦，提升性能测试能力


为什么给大家安排了这个主题呢？

首先，大家要清楚，我们现在的行业发展，其实纯手工测试的竞争力已经越来越低了。

为了节约成本，我们就需要找出对应的哪些服务器资源一直在浪费中，可以降配节约成本，哪些服务器对应的需要优化资源来达到用户使用体验更好。


首先，大家通过我们的实战练习，学会使用JMeter创建我们的压测脚本

然后压测脚本的具体指标可以上传到我们的实时的监控平台



学习计划（Plan）
时间	目标	内容
第一天	筑基	
第二天	提升	
第三天	拔高	


咱们这次的训练营会从基础的 压测脚本编写 开始讲解，然后再带着大家实时上传压测结果到监控平台。

这 3 天的安排是这样的。

第一天，是筑基的阶段。因为想要做压测监控平台，我们首先要有压测脚本，不能上来只是一个干巴巴的平台使用。所以第一天教给大家如何编写咱们实战的压测脚本。


等第一天的基础打好之后，第二天，我们就会带着大家学习 监控平台如何搭建。

等大家把 平台搭建完成后，我们就开始学习如何把压测数据实时上传到监控平台。

这就是我们 3 天直播的安排。

## 学习内容（Do）

https://v2.vip.ceshiren.com/#/course/course-center/pytest_comp

大家在训练营中学习的时候，可以直接进入咱们的学员中心去学习。

这里有大家需要提前学习的录播视频，然后咱们直播的入口也可以在这里看到。等直播结束之后，回放视频和对应的作业也可以从这里看到。

如果还有同学没有开通学员中心权限的话，大家可以扫描这个二维码进群，然后点击报名链接报名开通学习权限就可以了。

后面咱们课程中的一些资料，比如源码和一些总结性的文档，耶都会在群里提供给大家。

所以还没有进群的同学，抓紧扫码进群哈。

## 答疑服务（Do）

环境安装搞不定？

课程资料找不着？

练习过程有问题?


找助教班主任

咱们的答疑服务也是在群里提供给大家的。大家在学习过程中有任何问题，都可以在群里请助教老师帮助解决的。

这其实就是给大家提供了和咱们大课里一样的答疑服务了，就是为了让大家能更顺利的掌握这些技能。

大家也不要不好意思去问哈，因为有可能你的问题，让助教老师稍微点拨一下就可以解决，能最大程度的提高大家的学习效率。

## 作业检查(Check)

作业点评

这次也是给来参加咱们训练营的同学们提供了咱们大课才有的福利。

大家做完作业之后，肯定会想要知道自己的作业做的怎么样，哪里做的好，哪里做的可以继续优化，对吧。

所以这次咱们的训练营，可以给前 10 位提交课后作业的同学可以获得助教老师 1V1 的检查和点评。

大家记住，是前 10 位提交作业的同学。所以大家一定要积极的完成作业，尽早提交哈。

获得点评的同学，就可以在自己的学员中心中查看到老师点评的内容啦。

大家现在应该清楚怎么在咱们的训练营中学习了吧？知道的同学可以在咱们的讨论区扣1。


## 训练营成果演示

那咱们这次的训练营学习完之后，可以做出怎么样的效果呢？

先来给大家演示一下。



# 性能监控系统价值

首先介绍一下我们这个性能监控系统的价值，

第一块儿实际上是我们都知道这是一个比较庞大的一个架构图，这是一个微服务Spring Cloud架构图，
就是说我们任何一个服务端的应用，

实际上它的一个流量的入，以及中间会经历哪些的过程和流转，

同时伴随着是说这些流量流转涉及到的一些监控、搜集和日志展示的系统。

我们可以看一下，然后最左侧的这个三个，实际上相当于客户端，

比如说我们一个用户，比如说访问我们测试人的这个论坛地址这个网站，

那是用户可以选择用手机、电脑、平板，然后各种各样的方式，

甚至说一些我们做性能、接口测试的时候，也可以用JMeter客户端来去访问我们来去访问我们被测的服务。

无论是哪种访问方式，都会先经过一个大的前端服务Front-end，

这个服务的话，基本上来讲是流量的一个，我们会把它称为**流量层**，

一般通过HAProxy、NGinx来实现这一层

**HAProxy、NGinx主要做哪些事情呢？**

第一层HAProxy用于接收流量

第二层NGinx对接收到的流量根据配置的规则进行相对应的路由匹配及转发

以及NGinx还会承担比如说一些反向代理的能力

NGinx基于自己配置的规则和路由把把不同的服务或者

不同的请求去转发给后端微服务的网关层 gateway，

那spring cloud gateway只是一个网关服务，

他是如何能找到真正的比如说应用集体集群和应用实体的呢？？

实际上是通过上层的一个注册中心，就是每一个应用集群，

然后是通过注册中心nacos，然后把自己所提供的服务，

注册给spring cloud 的gateway，

这样就实现了gateway将这个对应请求分发到真正的应用实体上

这个应用集群实际上就是一个分布式的一个集群服务，

集群服务之间互相访问是通过注册中心nacos实现的

我们现在的产品都有一个用户登录，权限「淘宝、京东登录」

这个身份验证也是在这一层

也有可能是在Nginx使用ruby脚本，也有可能直接在应用层实现。

在网关层Gateway 负责我们常见的一些服务稳定性的一些能力，

他会借用一些工具，然后提供服务器的**熔断限流以及负载均衡**的策略，都会在这一层去实现，

然后另外一层再往下走，就走到应用集群，应用集群然后就是一个我们常见的一个分布式，

然后微服务架构，就是比如说这边应用集群可能是我们常见的一个电商系统，

就比如外卖系统，它可能这个分布式集群会有商家系统，

有订单系统，有购物车系统，也会有支付系统，所以说这些系统为服务系统，

整合起来会完成一个，整体的一个集群，

集群来讲的话，这是应对服务的部分，

再下一层就是会一些服务，

比如说**同步**来讲的话，他就直接去请求下一个服务或者请求存储，

如果**异步**来讲，他就直接去请求说，比如说发送的消息队列，然后提供其他的服务，

比如说另外一个应用拿来去消费，或者说异步去处理，这实际上是一个通用的一个流量架构。

#### 存储

再往下我们去看存储会分成哪些类？？

实际上会分成三类：

第一类 - 应用的内存存储「对象存储」。就是应用伴随着每台机器

>应用的内存缓存很难分布式，缓存打到我现在这台应用上的数据

真正的**分布式存储**，实际上在下方就是说我们的这个**缓存集群**

缓存集群我们常见的就比如说像redis、nosql、MongoDB

对于分布式来讲的话，一般是说我们常见的就是mysql
然后在真实场景下，我们会分成 **一主多从** 或者 **两主多从**
在比较常见的情况下是**一主多从**


主库负责读与写，主要负责写 、同时也承担小部分**需要事务的读流量**

从库主要是作为一些读流量存在的

一般是一主多从，因为常见的一个请求的模型来讲的话

读流量要远远大于的写流量

所以说这是数据库存储模型大概分三类

消息队列message queue，常见的rabbitMQ、Kafka 都是一层消息队列

会承载一些就不需要实时返回的一些异步消息通知

或者是做一些我们的削峰或者限流的场景

然后这实际上是说整个流量的应用和存储过程


大家可以看到，这种对于整个的互联网来讲的话

这整个的链路路是非常长的

那这个链路上如果没有可靠的一些监控或者说一些日志能力来讲的话

比较很难发现 现在系统健壮性是什么，

所以我们需要对系统进行各个模块的压测并且把对应性能数据上报，存在时序性数据库中

>时序性数据库InfluxDB 、或者普罗米修斯 

然后再由 Grafana 去进行展示，对应的Grafana也可进行相关的报警。


所以，我们我们给大家带来了这次的一个实战训练营。

当监控到一些异常报警了，就比如说response是500，那服务端是有错误的，

500的请求数是哪些，但是我们拿不到具体内容，就比如说500到底是因为什么错了

他的请求的具体参数是什么，所以说这时候对于整个系统来讲的话，我们就需要右上角的这个日志系统


## JMeter自带报告 VS 实时监控

传统的压测报告与实时监控的压测报告对比：



传统的压测报告和实时监控的压测报告是两种不同的方式来呈现性能测试结果。它们有各自的优缺点，可以根据具体的需求来选择使用。

传统的压测报告通常在性能测试结束后生成，展示的是整个测试过程中的数据和趋势。这种方式的优点是可以提供全面的测试结果，包括整个测试过程的响应时间、吞吐量、错误率等指标，便于测试人员和开发人员对性能问题进行分析和优化。缺点是不能提供实时的性能数据，需要等待测试结束后才能生成报告，无法及时发现性能问题。

实时监控的压测报告可以在测试过程中实时呈现性能数据和趋势。这种方式的优点是可以提供实时的性能数据，便于测试人员和开发人员及时发现性能问题并进行优化。缺点是只能提供测试过程中的性能数据，无法全面展示整个测试过程的数据和趋势，需要根据实时监控的结果进行推断和分析。

综合来看，传统的压测报告和实时监控的压测报告各有优缺点，可以根据具体的测试需求来选择使用。如果需要全面展示整个测试过程的数据和趋势，可以使用传统的压测报告；如果需要实时监控性能数据并及时发现性能问题，可以使用实时监控的压测报告。同时，也可以结合使用两种方式来提高测试效果和测试结果的准确性。



传统的压测报告和实时监控的压测报告都是在压测过程中用于分析性能指标的报告，但是两者有一些不同点。

1. 报告生成时间
传统的压测报告通常在整个压测任务结束后才生成，而实时监控的压测报告则可以在压测任务进行过程中实时生成。

1. 报告内容
传统的压测报告通常包括测试的基本信息、测试结果汇总、测试结果分析等，而实时监控的压测报告可以提供实时的性能指标数据、实时趋势图表等。

1. 报告应用场景
传统的压测报告通常用于分析和评估应用程序在不同负载下的性能，而实时监控的压测报告则可用于实时监控应用程序在压力下的性能表现，及时发现问题并进行调整。

1. 报告生成方式
传统的压测报告通常需要手动整理和生成，而实时监控的压测报告可以通过一些自动化工具来实现自动生成。

总的来说，传统的压测报告和实时监控的压测报告都有各自的优缺点，可以根据具体需求选择使用哪种报告方式。传统的压测报告适合对压力测试任务进行全面、深入的分析和评估，而实时监控的压测报告则适合及时监控应用程序的性能指标和快速发现问题。




JMeter聚合报告和Grafana报告都是用于分析性能测试结果的报告，但是它们之间有一些区别。

1. 报告生成方式
JMeter聚合报告是JMeter自带的一个报告，在测试结束后，JMeter会将测试结果自动汇总生成报告；而Grafana报告需要用户手动搭建并配置相应的数据源和监控指标，然后再进行监控和报告生成。

1. 报告内容
JMeter聚合报告提供了一些基本的性能指标数据，如平均响应时间、吞吐量、错误率等，但是数据展示较为简单；而Grafana报告可以根据用户需求自定义展示的指标、图表等，并且提供了更加灵活的数据可视化方式。

1. 报告应用场景
JMeter聚合报告主要用于简单的性能测试结果分析和报告生成，适合于小规模和简单的测试场景；而Grafana报告则适合于大规模和复杂的测试场景，可以提供更全面、更深入的性能数据分析和监控。

1. 数据存储方式
JMeter聚合报告默认将测试结果存储在JTL文件中，可以通过JMeter提供的工具进行读取和分析；而Grafana报告可以通过多种数据源进行数据存储和读取，如InfluxDB、Prometheus等。

总的来说，JMeter聚合报告和Grafana报告各自有其适用的场景，可以根据具体的测试需求选择使用哪种报告方式。JMeter聚合报告适用于小规模、简单的测试场景，Grafana报告则适合于大规模、复杂的测试场景，并且提供更加灵活、全面的性能数据展示方式。




## JMeter基础知识

## Docker基本用法

## 路线

### 计划和准备阶段

在这个阶段中，需要 **定义压测目标**、**制定压测计划**、**确定压测场景和负载模型**、**选择压测工具**和**测试环境**等。

还需要对测试应用进行配置和准备，包括安装、部署、配置和初始化等。

##### 压测目标

百度首页。

[Reqres API](https://reqres.in/)

![](assets/20230107100649.png)

#### 压测场景

压测百度网站的首页，查看请求结果是否正确返回。

[Reqres API](https://reqres.in/)


##### 压测URL

https://www.baidu.com/



##### 压测步骤

1. 访问被测页面：百度首页。

1. 校验返回值判断是否正确。


用JMeter生成一个接口的request请求，然后去访问百度的首页，在请求中需要添加**响应校验**，校验一下请求是成功还是失败。

>比如 压测的网站down 或者 当前发送请求的设备断网了 ，那对应的发送请求就没有意义，所以在访问完请求后需要校验一下结果。所以压测步骤里边分两步，一个是请求，一个是校验。

**Question**：JMeter里边最基础最基础的步骤是什么？？

一个是访问，一个是校验。无论是接口测试还是压力测试，既然是测试就一定要加上校验，一定要校验一下这次测试的是对的还是错的。这就是一个最基础的JMeter的一个使用方式。

##### 压测工具选择

JMeter。

##### 压测报告收集

聚合报告。


### 编写测试脚本

建立场景和数据准备阶段：在这个阶段中，需要定义测试用例和测试数据，包括创建场景、定义场景流程、创建用户和数据、定义负载模型、选择协议等。还需要进行场景测试和数据准备，包括模拟用户交互、记录日志、生成测试数据、加载测试数据等。


**编写测试脚本** ：根据测试场景和测试数据，编写测试脚本，模拟用户行为，以便进行性能测试。

编写一个JMeter压测脚本通常包括以下步骤：

#### 创建测试计划

打开JMeter并创建一个新的测试计划，命名并保存它。

1. GUI模式启动JMeter。
  
    ![](assets/20230106115317.png)

1. 命名保存。

    ![](assets/20230504153630.png)



#### 添加线程组

在测试计划下添加线程组，并设置线程数、循环次数等参数。

添加线程组：测试计划(Test Plan) -> 添加(Add) -> 线程(Threads) -> 线程组(Thread Group)

![](assets/20230107092806.png)


#### 添加HTTP请求

在线程组下添加HTTP请求，并设置请求方式、URL、参数等。

1. 添加HTTP请求：线程组(Thread Group) -> 添加(Add) -> 采样器(Sampler) -> HTTP 请求(HTTP Request)

    ![](assets/20230107094231.png)

1. HTTP请求编写：GET请求的 **服务器名称**、**路径** 和 **参数** 填写。

    ![](assets/20230107100755.png)


    ![](assets/20230107100941.png)
    >需要把被测的地址填到Web Server栏下，定义被测的请求类型「GET请求」，请求域名填写在Server Name里，对应的域名后的请求路径填写在Path中。

1. 查看请求结果：测试计划(Test Plan) -> 添加(Add) -> 侦听器(Listener)  -> 查看结果树(View Results Tree)。


    ![](assets/20230107101442.png)
    
    发送成功后，如下图示例：

    ![](assets/20230504171545.png)


##### 响应结果乱码

![](assets/20230504173110.png)


如果发送请求，返回的响应结果内容只要是中文的地方就显示为乱码，如何解决？

解决方案：

1. 发送请求时设置encoding为utf-8。---没有解决

1. 修改JMeter的配置文件，并重新启动JMeter，发送请求验证。

    >jmeter.properties --> sampleresult.default.encoding=ISO-8859-1 修改为sampleresult.default.encoding=UTF-8


#### 添加断言

在HTTP请求下添加断言，以验证请求的响应是否符合预期。

如果用浏览器访问，在浏览器上看到的内容就是需要校验的点，说你能看到什么东西，就能证明说你是真正访问到了当前请求的网页。请求到了网页，不能说兜了一圈什么都没有干就直接回来了。那在JMeter中怎么证明这个请求的网页会返回很多东西呢？就是在脚本中直接添加断言组件。


**断言是一种用于验证响应的测试元素。**

你需要校验一下什么内容呢？
你就需要校验一下你对百度的这个网站请求发出去之后，百度给你的一个响应。通过查看结果树的response可以看到一个title标签为：**百度一下，你就知道**。


1. 响应断言：请求组件(HTTP Request) -> 添加(Add) -> 断言(Assertions)  -> 响应断言(Response Assertion)。

    ![](assets/20230504173714.png)
    

##### 响应断言组件

![](assets/20230504180233.png)

可以根据需求对响应进行不同类型的验证。以下是常见的响应断言组件：

响应代码断言：用于验证响应是否包含特定的 HTTP 状态码。如果响应不包含特定的状态码，则断言失败。

响应消息断言：用于验证响应是否包含特定的文本消息。如果响应不包含特定的消息，则断言失败。

包含断言：用于验证响应是否包含指定的文本。如果响应不包含指定的文本，则断言失败。

![](assets/20230509162833.png)



包含正则表达式断言：用于验证响应是否包含符合特定正则表达式的文本。如果响应不包含符合正则表达式的文本，则断言失败。

XML 验证断言：用于验证 XML 响应是否符合指定的 XSD 模式。如果响应不符合指定的 XSD 模式，则断言失败。

HTML 验证断言：用于验证 HTML 响应是否包含指定的 HTML 标签和属性。如果响应不包含指定的 HTML 标签和属性，则断言失败。

在使用响应断言组件时，请确保选择适当的类型，并对其进行适当的配置，以确保它可以正确地验证您的响应。





就是说你这个响应，如果你要是流用浏览器访问的话，你在浏览器上面能看到东西，
那么你需要校验一下，说你能看到什么东西，就能证明说你是真正访问到了百度，
你的这个请求是，到了百度，而不是说兜了一圈什么都没干完又回来了，就这么一个目的，
那怎么能证明呢，那么百度的那个网页上会返回很多东西，那么在里边其中会有一个，
会有一个文本的那样一个字样，叫做，
所以我们在response里面可以加一个就是text text text response就是文本校验，
就是你这个response里面如果有这段文本，那我就认为说你这个请求是成功的，
那你可以加一个tex response完了在那个pattern to test里面
加一个contains contains就是包含，包含百度一下你就知道，只要包含这个文本，
那么我们的这次请求就算一个成功的正确的请求，就是这么一个意思，



![](assets/20230509164106.png)


![](assets/20230509164233.png)

![](assets/20230509164205.png)

![](assets/20230509163850.png)

![](assets/20230509164259.png)

![](assets/20230509164313.png)

![](assets/20230509164325.png)

![](assets/20230509164337.png)

![](assets/20230509164354.png)




##### 添加监听器

在HTTP请求下添加监听器，以收集请求响应的数据，如响应时间、吞吐量、错误率等。


##### 进行压测

运行测试计划，并收集测试数据。


### 搭建性能监控平台

展示更好看的报告

ssh root@81.70.96.121


查看当前服务器上docker容器内有哪些服务在使用中。
![](assets/20230508135010.png)

```bash
# 安装docker


# 下载最新版本的influx DB 镜像 
docker pull influxdb
```

使用 yum search docker就可以查看到所有的docker版本的信息。


# 



centos7.6版本以上的系统直接用yum install docker



# day2
全链路压测

全链路线上压测