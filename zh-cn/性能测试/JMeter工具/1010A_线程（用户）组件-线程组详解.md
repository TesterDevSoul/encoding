# 文章名



## 本章要点
1. 要点一
1. 要点
1. 要点
1. **要点**


## 学习目标

1. Window系统安装并打开JMeter工具。


## 思考

## 介绍

线程组（Thread Group）是JMeter中一个非常重要的组件，它**定义了测试计划中虚拟用户的行为**。

线程组表示一组交互的虚拟用户，模拟真实环境中的多用户（客户端）访问。

线程组可以帮助你设置并发用户数量、执行过程的逻辑以及整个测试的持续时间。


1. 测试计划
## 添加

添加线程组，**测试计划**(`Test Plan`) -> **添加**(`Add`) -> **线程**(`Threads`) -> **线程组**(`Thread Group`)

![](assets/20230107092806.png)


## 界面

![](assets/20230608162723.png)


### 在取样器错误后要执行的动作

Action to be taken after a Sample error：**在请求取样器执行错误时需要执行的下一步动作**。

![](assets/20230608183109.png)

#### 继续

continue：继续执行接下来的操作。

执行：

**线程组1**

HTTP请求1 --> HTTP请求2 Error --> HTTP请求3 --> 

HTTP请求1 --> HTTP请求2 Error --> HTTP请求3


#### 启动下一进程循环

startnextloop：忽略错误，执行下一个循环。

>错误后的循环不再执行，启动下一个循环。

执行：

**线程组1**

HTTP请求1 --> HTTP请求2 Error --> 

HTTP请求1 --> HTTP请求2 Error --> 

...

#### 停止线程

stopthread：退出该线程（不再进行此线程的任何操作），但是不影响当前测试计划下其他的线程组。


执行：

**线程组1**

HTTP请求1 --> HTTP请求2 Error --> 停止当前线程


#### 停止测试

stoptest：等待当前执行的采样器结束后，结束整个测试

当前线程中的请求，已经开始发送的请求，会在它请求发送完成并获得对应结果后，停止测试。

#### 立即停止测试

stoptestnow：直接停止整个测试，当前执行的取样器可能会中断。

不会等着请求完全响应成功后再停止。

### 线程属性

#### 线程数

Number of Thread (users)：模拟的用户数量，表示并发用户数量（同时操作应用程序的虚拟用户数）。

#### Ramp-up时间（秒）

Ramp-up Period（in seconds）：达到指定线程数所需要的时间。在**设置时间内启动** 所有线程「**上面设置的线程数**」。

>举例：线程数设置为50，此处设置为5，那么每秒启动的线程数 => 线程数50/5 = 10

设置Ramp-up时间内，把请求发送出去，但是**不包括请求返回结果的时间**。

#### 循环次数

Loop Count：线程组结束前每个线程循环的次数。**上面设置的线程数，执行的次数**。

**勾选☑️永远**，若**未设置运行时间**，需要**手动停止**。

在每次循环内，线程组中的所有取样器和逻辑控制器将按顺序执行。

设置为1意味着每个虚拟用户将执行一次完整的测试过程。


![](assets/20230609114408.png)

>10个请求循环5次，一共是50个线程请求。

#### Same user on each iteration

每次迭代都用相同的用户，**勾选☑️**该选项则**不同次迭代之间取样器是串行执行**，**不勾选**则为**取样器并行执行**。

#### 延迟创建线程直到需要

`Delay Thread creation until needed`：当线程需要执行的时候，才会被创建。

如果**不勾选**，那么，在计划开始的时候，所有需要的线程就都被创建好了。

![](assets/20230609115004.png)

>有setUp 线程组时，勾选延迟创建线程直到需要，则运行完setUp 线程组才会创建线程组1的请求。否则会在运行前就创建线程组1的请求。 


#### 调度器

Scheduler：**勾选☑️**此选项，你可以定制测试持续时间以及线程组的启动和停止时间。这在长时间测试和资源管理时非常有用。

#### 持续时间（秒）

Duration (seconds)：在此选项填入数字N，说明这个计划，从某个开始时间算起，执行N秒后结束。（会忽略 结束时间 的选项）

![](assets/20230609115604.png)

>100个并发执行5次，如果在60s内还未完成。JMeter也会结束你当前的压测请求，会把当前发出的请求完成，但是不会再创建新的请求实例。

![](assets/20230609115825.png)

>把JMeter从循环次数的维度控制改编成从持续时间的一个维度去控制。100个线程不管循环请求多少次，持续压60s结束，在60s时，JMeter把当前请求完成，但是不会创建新的请求。



#### 启动延迟（秒）

Startup delay (seconds)：在此选项填入数字N，手动点击开始执行计划，然后延迟N秒后，计划才真正开始执行。


![](assets/20230609120342.png)

>设置了启动延迟20s，则在开始时，前20s是没有请求发送的，等过完20s后，才会发送请求，但是整体时间是60s，也就是发送压测请求也就40s「60-20」的时间。
「**发送并发请求的时间 = 持续时间（秒） - 启动延迟（秒）**」

>配置持续时间（秒）和启动延迟（秒）来控制每个线程组的持续时间及启动后的秒数。测试开始时，JMeter启动线程组的线程之前等待启动延迟（秒），然后运行配置的持续时间（秒）。

>10个线程，启动周期为100秒。JMeter花费100秒来启动和运行所有10个线程。每个线程将在上一个线程开始后10秒「100/10」开始。<br>如果有30个线程，启动周期为120s，每个连续线程将延迟4s启动。



## 总结
- 总结一
- 总结二
- 总结三
https://github.com/Wechat-ggGitHub/Awesome-GitHub-Repo

[项目演示地址](https://github.com/testeru-pro/junit5-demo/tree/main/junit5-basic)


# 学习反馈

1. SpringBoot项目的父工程为( )。

   - [x] A. `spring-boot-starter-parent`
   - [ ] B.`spring-boot-starter-web`
   - [ ] C. `spring-boot-starter-father`
   - [ ] D. `spring-boot-starter-super`


<style>
  strong {
    color: #ea6010;
    font-weight: bolder;
  }
  .reveal blockquote {
    font-style: unset;
  }
</style>


