# 接口抓包与 Mock 内容梳理

同学们大家好，从这周开始我们进入接口测试的学习。

之前我们在学习 web 测试和 app 测试的时候就提过，接口对于 web 项目和 app 项目都非常的重要。接口就是前端 UI 界面和后端服务数据交互的桥梁。


## 接口测试概念

接口：不同的系统之间相互连接的部分，是一个传递数据的通道
接口测试：检查数据的交换、传递和控制管理过程
接口到底是什么呢？

单说接口，其实是一个比较大宽泛的概念，主要表示系统对外交互的部分。就拿我们日常生活中的场景来说，比如**电源插座是电器和电能之间的接口，图形界面是应用软件和用户的接口，电梯按钮是乘客和电梯之间的接口**。

所以说接口，其实就是的就是两个不同的系统之间相互连接的部分。

它是一个传递数据的通道，是我们产品系统各个组件之间数据传递的通道。只要将数据送入这个通道，我们就可以获取到需要的数据。

至于里面获取数据的底层逻辑、业务实现，我们不用需详细的做了解。

**接口就是交互的桥梁。**

大家都知道，咱们现在的产品基本都是前后端分离开发的。

也就是 UI 界面和后端服务是分开开发的。这样的开发模式，就决定了如果前端要和后端进行数据交互的话，必须要有一个桥梁来进行沟通。那这个桥梁其实就是我们说的接口。

也就是前端和后端要进行数据交互的话，都是需要通过接口的。（图）


##### 什么是接口？

>有输入参数和输出内容的，并且有一套有逻辑处理单元

- 输入 ---> 处理 ---> 输出

我们也可以把这里的接口叫做 API（Application Programming Interface），其实本质上就是后端的开发预先定义好的函数，这些函数可以给我们提供一些确定的功能和服务。

比如**有的接口可以完成数据的查询**，有的可以提供图片，**有的可以完成数据的存储**。等等。




### 接口分类

要进行数据交互的时候，前端会先发送对应的请求给接口，接口收到请求后会去调用对应的后端方法得到响应结果，然后接口再把响应结果返回给前端。

通过这些接口，我们的客户端和服务端之前进行了一系列的数据交互。这种接口也叫做**程序内部接口**。

除了**内部接口**之外，还有**外部的接口**。

公司内的业务叫内部接口，与外部对接的叫外部接口。「第三方接口都是其他公司的外部接口」

>比如从京东购物，我们会在京东app上面选择商品，然后加入购物车，再下订单，那这个过程就是京东自己各个模块调用自己内部的接口。

>但是，当付款的时候跳转到支付页面，我们都知道这个页面可以选择不同的支付方式，比如：微信支付、云闪付、好友代付等等。等你完成支付流程后，再跳转回订单页，在付款的流程中，都会涉及系统对外的接口，比如说需要使用微信支付，那对应的京东就需要调第三方微信的支付接口。

>还有，比如说后期商品配送过程的物流接口，也是需要对接第三方接口。

公司内部接口对接第三方接口的时候会遵循特定的规则：

- 在开发前期，我们约定接口会接收什么类型的数据；在处理完成后，它又会返回什么类型的数据。


外部接口常见的例子就是通过**第三方登录**、第三方支付等，通过调用第三方的接口并返回当前的系统。


知道了什么是接口之后，我们再来看什么是接口测试。

### 接口测试

假如你现在测试的是一个 `Web` 端的论坛，那么 `Client` 端「前端页面」就是浏览器，`Server` 端就是 `Web` 的服务器，那么 浏览器 和 `Web` 服务之间，就是通过 `HTTP` 协议传输的；

如果测试的是移动端的`APP`，比如：企业微信 ，那么 `Client` 端「前端页面」就是你的设备上安装的 企业微信 应用，`Server` 端就是 `RESTful` 格式的接口服务，那么  企业微信 的应用和 `RESTful` 格式的接口服务，就是通过 `JSON` 格式的数据来传递的。

>比如说，用`postman`或者`JMeter`做对应的手工接口测试，还可以用`Charles`跟`Fiddler`，这些就是测试我们的接口，看看发送的请求链接传递的参数对不对，返回值是不是预期的内容。

>在浏览器上输入`https://www.baidu.com/`，浏览器会把这个`http`请求发送给指定的后端服务，后端服务根据请求的`API`地址，来进行逻辑处理，并把处理完的接口再返回给页面，页面把结果转换出来呈现给我们变成了前端页面。

>登录、注册接口，发送`Http`请求的时候，会把在前端页面传入的参数进行一个传递，现在一般涉及到用户相关信息的都会进行加密处理。通过`Http`协议把对应的参数和路径发送给了后端服务，后端服务根据研发写的相关的业务逻辑代码进行处理，并`return`结果，后端服务把`return`的内容返回给前端。就是返回接口的响应结果，前端根据响应内容进行渲染加载，返回的结果一般都是`json`格式，有可能有状态码{200或者404}，还会有相关的message提示内容，前端最终呈现给用户。
>后端服务，现在一般都是微服务、集群式的，为了各个业务模块之间的调用，还会有中间件的内容。我们只关注发送请求的结果是否为预期的内容，至于后端服务的代码相关业务逻辑调用流转，是不需要进行关注的。

看到这，我想你也能理解了，接口测试其实就是模拟调用方，比如 Client 端，通过接口通信来检测被测接口的正确性和容错性。

### 接口价值

（看图）

服务端非常复杂。我们来看一个 2012 年的时候淘宝核心链路应用的拓扑图。这已经是 10 年前的一个链路图了，我们就用淘宝公开出来的这样一个架构图，让大家能对后端服务的复杂性有一个比较直观的了解。

图里面的每一个点都代表了一个模块，也就是我们后端的一个服务。

比如当一个用户购物的时候，浏览，把一个东西放入购物车，登录，接下来产生交易，每一步用户的行为，后面都连接了很多个模块。通过各种依赖和组合，对用户的数据进行了全面的处理。

比如说一个用户登录进来，那他要调用登录接口，接下来他就可以看到商品的详情页，用户的个人信息页，包括你要给他展现的广告等等。这就需要非常庞大的服务端组件的支持，通过各种配合，才能提取出来各种信息。

我们来看看这张图上的模块的组合和情况。一列有 15 个模块，然后有 10 列。这还是 9 年前的架构。现在的复杂度肯定要比图上的还要复杂。所以这张图我们就能看出来，公司里面真实的后端服务是非常复杂的。

那这么多模块，不可能一个团队去保证质量。基本上是每个模块都有专门的团队去负责。少则二三个人，多则十几二十个人，大家会维护这些东西，所以说需要的团队成员也是非常多的。

当这些模块集成到一块的时候，比如其中有的模块是一个月变更一次，有的模块两周变更一次。

就单个模块来说可能变更的频率不是很大，两周或者一个月是属于正常水平。但是这么多模块集成到一起了，整个网状的结构，它的调用关系，其实可能是每天都会有更新。

这样庞大的变化，就会给我们测试人员带来压力。可能我们上一轮测试还没有测完，我们调用的网络结构就已经发生了变化。由于模块发生了升级，可能调用链路就发生了变化。

在这种情况下，我们传统的一些测试方法可能就不实用了。在我们的产品功能越来越复杂，变化越来越快的情况下，普通的瀑布流的测试，就已经跟不上公司的发展变化了。

基于这种情况，我们就需要研究出来的新的测试方法和测试策略，去想办法应对这种变化。

其实目前最好的方法就是分层测试。我们把测试分为前端和后端，后端变化的时候，后端测试工程师单独去测。那前端的测试工程师专注于前端的测试就好了。

分层完成之后，对于每一个组件其实还可以继续拆分，现在很多公司都采用微服务化。微服务化对应的每一个组件都需要有一个对应的测试。既有单元测试，又有单模块的一个接口测试，又有整个集群的整体的端到端的一个 api 的接口测试。最后再到 UI 端，完成 UI 端的测试。

除了分层，其实自动化也是必不可少的。没有自动化的话，这么大的一个集群其实也是没有办法测的过来的。

所以说当前情况下传统的 UI 测试成本越来越高，效率本身又比较低，已经不能完全满足保证质量的需求了。

那么分层之后，我们就可以通过接口测试来快速保证后端服务的质量。具体分层要怎么来分呢？

## 测试策略

接口测试要比 UI 层面的测试更底层，效率更高，收益更大。

保证了接口的正确性，对于前端的数据正确性也有了保证。所以，接口现在都是会专门去进行测试的。

在这里给大家介绍两种测试策略模型。

首先，先跟大家说一下对应的互联网的产品和传统软件产品有什么不同。

首先，互联网产品的“快”。
>互联网产品的上线周期通常是以“天”甚至是以“小时”为单位，而传统软件产品的周期多以“月”，甚至以“年”为单位。

发布周期的巨大差异决定了，传统软件产品的测试策略必然不适用于互联网产品的测试，二者的测试策略必然在测试执行时间和测试执行环境上有巨大差异。

>比如，对于功能自动化测试用例，执行一轮全回归测试需要 12 小时，对传统软件来说这根本不是问题，因为发布周期很长，留给测试的时间也会很充裕。不要说全回归测试执行时间需要 12 小时，哪怕是需要几天几夜也没有任何问题。

做传统软件测试时，一轮完整的全回归测试的 GUI 测试用例数接近 3000 个，API 测试用例数更是接近 25000 个，跑完全部用例需要将近 60 小时。

但对互联网产品来说，通常 24 小时就会有一到两次的发布，一周一个小迭代版本，或者需求。

发布流程通常包含了 **代码静态扫描**、**单元测试**、**编译**、**打包**、**上传**、**下载**、**部署**和**测试**的全流程。

显然留给测试执行的时间就非常有限，传统软件至少十天半个月的测试执行时间，在互联网产品的测试上，根本行不通。


通常情况下，**互联网产品要求全回归测试的执行时间不能超过 4 小时**。

那么，如何在保证测试质量和测试覆盖率的前提下，有效缩短测试执行时间呢？

首先，你可以引入测试的并发执行机制，用包含大量测试执行节点的测试执行集群来并发执行测试用例。

测试执行集群，你可以简单理解为是一批专门用来并发执行测试用例的机器。

常见的测试执行集群，由一个主节点（Master）和若干个子节点（Node）组成。

其中，主节点用来分发测试用例到各个子节点，而各个子节点用来具体执行测试用例。

目前，很多互联网企业都建立了自己的测试执行集群。

其次，就必须从测试策略上找到突破口，这也是这页PPT的内容。接下来，先简单介绍一下传统软件产品的测试策略设计，然后再给介绍一下互联网产品的测试策略，这样可以通过对传统软件产品测试策略的回顾，加深你对互联网产品测试策略的认识。

### 金字塔模型

传统软件产品的测试策略设计，在很长一段时间内都被认为是测试策略设计的最佳实践。

**重单元测试，API测试次之，轻GUI测试**。

越往上，发现 Bug 的时间越晚，成本越高。

接口测试（Service）相比 UI 测试，可以更早发现问题，更快的质量反馈。

![金字塔模型](https://cdn.jsdelivr.net/gh/TesterDevSoul/blog_pic/test_strategy/20210715185640.png)


#### 单元测试

金字塔最底部是单元测试，属于**白盒**测试的范畴，通常由开发工程师自己完成，由于越早发现缺陷其修复成本越低，所以传统软件产品的测试策略提倡对单元测试的高投入，单元测试这一层通常都会做得比较“厚”。

另外，传统软件产品，生命周期都比较长，通常会有多个版本持续发布，为了在后期的版本升级过程中能够尽早发现并快速定位问题，每次 build 过程中都会多次反复执行单元测试，这也从另一个角度反映出单元测试的重要性。


#### API 测试

金字塔中间部分是 API 测试，主要针对的是各模块暴露的接口，通常采用灰盒测试方法。

灰盒测试方法是介于白盒测试和黑盒测试之间的一种测试技术，其核心思想是**利用测试执行的代码覆盖率来指导测试用例的设计**。

以 API 接口测试为例，首先以黑盒方式设计如何调用 API 的测试用例，同时在测试执行过程中统计代码覆盖率，然后根据代码覆盖率情况来补充更多、更有针对性的测试用例。

总体来看，API 测试用例的数量会少于单元测试，但多于上层的 GUI 测试。

#### GUI 测试

金字塔最上层的是 GUI 测试，也称为**端到端**（E2E，End-to-end）测试，是最接近软件真实用户使用行为的测试类型。

通常是模拟真实用户使用软件的行为，即模拟用户在软件界面上的各种操作，并验证这些操作对应的结果是否正确。

GUI 测试的**优点**是，能够**实际模拟真实用户的行为，直接验证软件的商业价值**；

**缺点**是**执行的代价比较大**，就算是采用 GUI 自动化测试技术，用例的维护和执行代价依然很大。

所以，要尽可能地避免对 GUI 测试的过度依赖。

另外，GUI 测试的**稳定性问题**，是长期以来阻碍 GUI 测试发展的重要原因。

即使你采用了很多诸如 **retry** 机制以及**异常场景恢复机制**等方式，GUI 测试的随机失败率依旧高居不下。



### 菱形模型

![互联网测试策略](https://cdn.jsdelivr.net/gh/TesterDevSoul/blog_pic/test_strategy/20230331143400.png)

互联网产品的测试策略设计对于互联网产品来说，迈克的金字塔模型已经不再适用，我会通过 GUI 测试、API 测试、单元测试这三个方面，来跟你聊聊互联网产品的测试策略有哪些变化，应该如何设计。

遵循“**重量级 API 测试，轻量级 GUI 测试，轻量级单元测试**”的原则。

#### GUI 测试

GUI 测试互联网产品的上线周期，决定了 GUI 测试不可能大范围开展。

互联网产品的迭代周期，决定了留给开发 GUI 自动化测试用例的时间非常有限；

互联网产品客户端界面的频繁变化，决定了开展 GUI 自动化测试的效率会非常低，这也是最糟糕的。

因为敏捷模式下的快速反馈，在下一个迭代（sprint）可能就需要根据反馈来做修改和调整客户端界面，那么刚开发完，甚至是还没开发完的 GUI 自动化测试用例就要跟着一起修改。

这种频繁地修改，对开发 GUI 自动化测试是非常不利的。因为，刚开发完的自动化用例只跑了一次，甚至是一次还没来得及跑就需要更新了，导致 GUI 自动化测试还不如手工测试的效率高。

由此，互联网产品的 GUI 测试通常采用“**手工为主，自动化为辅**”的测试策略，手工测试往往利用探索性测试思想，针对 **新开发或者新修改的界面**功能进行测试，而自动化测试的关注点主要放在 **相对稳定且核心业务的基本功能**验证上。

所以，**GUI 的自动化测试往往只覆盖最核心且直接影响主营业务流程的 E2E 场景**。

另外，从 GUI 测试用例的数量来看，传统软件的 GUI 测试属于重量级的，动不动就有上千个用例，因为传统软件的测试周期很长，测试用例可以轮流排队慢慢执行，时间长点也没关系。

而互联网产品要求 GUI 测试是轻量级的，你见过或者听过有哪个互联网产品设计了上千个 GUI 测试用例吗？

互联网产品的上线周期，直接决定了不允许你去执行大量的用例。


#### API测试

既然互联网产品不适宜做重量级的 GUI 测试，那么怎样才能保证其质量呢？

其实，对于互联网产品来说，把测试重点放在 API 测试上，才是最明智的选择。为什么呢？

我给你总结了以下五条原因。

##### 1.API 测试用例的开发与调试效率比 GUI 测试要高得多

API 测试用例的开发与调试效率比 GUI 测试要高得多，而且测试用例的代码实现比较规范，通常就是准备测试数据，发起 request，验证 response 这几个标准步骤。

##### 2.API 测试用例的执行稳定性远远高于 GUI 测试

GUI 测试执行的稳定性始终是难题，即使你采用了很多技术手段，它也无法做到 100% 的稳定。

而 API 测试天生就没有执行稳定性的问题，因为测试执行过程不依赖于任何界面上的操作，而是直接调用后端 API，且调用过程比较标准。

##### 3.单个 API 测试用例的执行时间往往要比 GUI 测试短很多。

当有大量 API 测试需要执行时，API 测试可以很方便地以并发的方式执行，所以可以在短时间内完成大批量 API 测试用例的执行。

##### 4.微服务测试

现在很多互联网产品采用了微服务架构，而对**微服务**的测试，本质上就是对不同的 Web Service 的测试，也就是 API 测试。

在微服务架构下，**客户端应用的实现都是基于对后端微服务的调用**，如果做好了每个后端服务的测试，你就会对应用的整体质量有充分的信心。所以，互联网产品的 API 测试非常重要。

##### 5.后向兼容性

API 接口的改动一般比较少，即使有改动，绝大多数情况下也需要保证后向兼容性（Backward Compatibility）。

所谓**后向兼容性**，最基本的要求就是保证原本的 API 调用方式维持不变。

显然，如果调用方式没有发生变化，那么原本的 API 测试用例也就不需要做大的改动，这样用例的可重用性就很高，进而可以保证**较高的投入产出比**（ROI）。


可见，互联网产品的这些特性决定了，API 测试可以实现良好的投入产出比，因此应该成为互联网产品的测试重点。这也就是为什么互联网产品的测试策略更像是个菱形结构的原因。


#### 单元测试

单元测试了解了“重量级 API 测试”和“轻量级 GUI 测试”，接下来，说说为什么是“轻量级单元测试”。

从理论上讲，无论是传统软件产品还是互联网产品，单元测试都是从源头保证软件质量的重要手段，因此都非常重要。

但现实是，互联网产品真正能全面开展单元测试，并严格控制代码覆盖率的企业还是凤毛麟角。

但凡存在的都会有其合理性，我认为最主要的原因还是在于互联网产品的“快”，**快速实现功能，快速寻求用户反馈，快速试错，快速迭代更新**。

在这样的模式下，互联网产品追求的是最快速的功能实现并上线，基本不会给你时间去做全面的单元测试。

即使给你预留了单元测试的时间，频繁的迭代也会让单元测试处于不断重写的状态。

因此，单元测试原本的价值，很难在实际操作层面得到体现。

那么，互联网产品真的可以不用做单元测试么？答案是否定的，只不是这里的单元测试策略要采用“**分而治之**”的思想。

互联网产品通常会分为**应用层**和**后端**服务，**后端服务**又可以进一步细分为**应用服务**和**基础服务**。

**后端基础服务**和**一些公共应用服务**相对稳定，而且对于系统全局来说是“牵一发而动全身”，所以后端服务很**有必要开展全面的单元测试**；

而对于变动非常频繁的客户端应用和非公用的后端应用服务，一般很少会去做单元测试。

另外，对于一些**核心算法**和**关键应用**，比如**银行网关接口**，**第三方支付集成接口**等，也要做比较全面的单元测试。

总结来讲，互联网产品的全面单元测试只会应用在那些**相对稳定和最核心的模块和服务上**，而应用层或者上层业务服务很少会大规模开展单元测试。

### 四个关键点

菱形模型有以下四个关键点：

以中间层的 **API 测试为重点**做全面的测试。

轻量级的 **GUI 测试**，**只覆盖最核心直接影响主营业务流程**的 E2E 场景。

最上层的 **GUI 测试**通常利用**探索式测试思维**，以人工测试的方式发现尽可能多的潜在问题。

**单元测试**采用“**分而治之**”的思想，只对那些**相对稳定并且核心的服务和模块**开展全面的单元测试，而**应用层或者上层业务**只会做**少量**的单元测试。



## HTTP 协议

HTTP 协议：超文本传输协议（HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。是用于分布式、协作式和超媒体信息系统的应用层协议。

但是 HTTP 协议的安全性不是很好，所以后面又发展出了 HTTPS 协议。现在其实大部分使用的都是 `HTTPS` 协议。

HTTPS 协议：（HyperText Transfer Protocol over Secure Socket Layer）简单讲就是HTTP协议的安全版，在 HTTP 协议下加入了 SSL 层。

SSL：（Secure Socket Layer 安全套接层）安全传输协议，在传输层对网络连接进行加密，保障在 Internet 上数据传输的安全。

这里有一个常识大家要知道

HTTP 的默认端口：80
HTTPS 的默认端口：443

我们现在大部分使用的都是 HTTPS 协议。不过我们一般就是直接统称为 HTTP 协议了。


#### HTTP 协议与接口测试的关系
HTTP 协议也是接口测试中最常见的协议，HTTP 是万维网的数据通信的基础。客户端向服务端发送 HTTP 请求，服务端则会在响应中返回所请求的数据。

我们做接口测试，其实就是要校验发出去的请求是否正确，得到的响应结果是否正确，所以了解 HTTP 协议，对于接口测试来说，是重中之重。

要发出请求，要先知道我们需要的资源在哪里。所以下面先来了解一个概念。




## URL 结构

https://www.baidu.com/s?wd=霍格沃兹&rsv_spt=1


从上面的 URL 可以看出，一个完整的 URL 包括以下几部分：

**协议部分**：“http：”，这代表网页使用的是 HTTP 协议。在"HTTP"后面的“//”为分隔符

**域名部分**：www.baidu.com。一个 URL 中，也可以使用 IP 地址作为域名使用

**端口部分**：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口

**路径**：从域名后的最后一个“/”开始到“？”为止，是资源所在路径


#### 链接1

- https://ceshiren.com/c/185-category/186-category/186

在上面的URL中：

- 协议部分是：https://
- 主机名是：ceshiren.com
- 路径部分是：/c/185-category/186-category/186


#### 链接2

- http://81.70.96.121:10240/login?from=%2F

在上面的URL中：

- 协议部分是：http://
- 主机名是：81.70.96.121:10240
  - IP/域名：81.70.96.121
  - 端口：10240
- 路径部分是：/login
- 查询参数部分是：?from=%2F
  - 参数from的值是：%2F


#### 链接3

- https://en.wikipedia.org/wiki/Java_(programming_language)#History

**锚部分**：从“#”开始到最后，都是锚部分。本例中的锚部分是“History”。锚部分也不是一个 URL 必须的部分

**参数部分**：从“？”开始到“#”为止之间的部分为参数部分。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。


- https://www.example.com/search?q=example&sort=price#results

在上面的URL中：

- 协议部分是：https://
- 主机名是：www.example.com
- 查询参数部分是：?q=example&sort=price
  - 参数q的值是：example
  - 参数sort的值是：price
- 锚部分是：#results，指向文档内的某个锚点

查询参数部分是URL中用于传递额外信息的一部分，它以问号 ? 开头，参数之间用 & 分隔。在上面的示例中，参数 q 和 sort 都包含在查询参数部分中。

锚部分是URL中用于指定文档内的某个锚点的一部分，它以 # 开头，后面跟着锚点的名称。在上面的示例中，锚部分指向了文档内的某个名为 results 的锚点。

## HTTP 请求报文

**请求行**：请求方法、请求资源的 URL、HTTP 版本信息。
**首部行**：请求行的下一行一般为首部行的开始，包括主机域名、连接信息、用户代理等等信息。
**实体主体**：一般不使用。

### 请求行

请求方式、URL、HTTP 版本。


首先是请求行，请求行以一个方法开头，后面跟着请求 URL 和协议的版本。

### 请求头

然后就是请求头信息。

请求头部
头信息，我们平常会叫做 header，请求有头信息，响应也有头信息。这里我们看到的就是请求头。是发送请求时携带的头部信息。

通常一些鉴权的信息、响应的数据格式等等的设置。我们来看看比较常见的有哪些。

- **HOST**：主机地址和端口号
- **Connection**：表示客户端与服务器的链接类型：keep-alive 表示长链接，会保持连接状态。如果设置了代理抓包，就会变成 Proxy-Connection ）
- **User-Agent**：客户端名称，代表是谁发出的请求
- **Accept**：传输文件类型，指客户端可以接受的文件类型，服务器可以根据它判断并返回适当的文件格式：
>可能的值：text/html,application/xhtml+xml;q=0.9,image/*;q=0.8;application/json:表示浏览器支持的文本类型分别为 html文本、xhtml和xmlendanger、所有的格式图像资源；
Text：文本信息，可以是多种字符集的和或者多种格式的；

- **Application**：用于传输应用程序数据或者二进制数据；
q：权重系数，范围为1 >= q >=0，q值越大，越靠前。默认为1，按从左到右排序顺序，q值为0，表示浏览器不接受此类型。

- **Referer**：页面跳转处，表示请求的网页来自哪个 URL。这个属性可以用来追踪请求来自哪个页面，是从什么网站来的等等，用来防盗链或者统计网站流量

- **Application-Encoding**：文件编解码格式，指出客户端可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到Web响应之后会先解码，然后再检查文件格式，许多情况下这可以节省大量的下载时间；gzip, deflate
- **Accept-Language**：语言种类，指出浏览器可以接受的语言种类，如 en或 en-us 表示英语，zh 或者 zh-cn 表示中文，当服务器能够提供一种以上的语言版本时要用到

- **Accpet-Charset**：字符编码，指出浏览器可以接受的字符编码。如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受；
- **Cookie**：向服务器发送 Cookie。>Cookie 是用来记载和服务器相关的用户信息，也可以用来实现会话功能。比如用户登录的时候，认证成功后，会返回 token 和 auth，在下次请求拼接成一个 Cookie 信息
- **Content-Type**：POST 请求里用来表示的内容类型

- **Cache-Control**：对缓存进行控制，max-age= 0：明确表示不会缓存服务器资源；

### 请求参数

我们在请求的时候也可以携带参数。携带参数有两种不同的形式。一种是**直接拼接在 url **中的。

比如我们上面演示的这种，在 url 后面，通过 ？连接的 key=value 的形式。这种一般会叫做 **params**。

还有一种形式是可以放到 **body** 当中，我们一般会叫做**请求体**。这种形式在 url 中就看不到请求参数的内容了。 **POST/PUT**请求。

这是两种不同的携带参数的方式，会应用在不同的请求方式中

这里大家需要分清楚 parmas 是拼接在 url 中的，还有一种把内容放在 body 中的方式就可以。


```bash
curl -v "https://ceshiren.com/"
```

-v参数输出通信的整个过程，用于调试。

可以看到浏览器和curl命令发送的请求中**user-agent** 不同。

接下来我们再来看 http 的响应信息里都包含了哪些内容。

## HTTP 响应报文

服务器接收到请求后，会返回 `HTTP` 响应

### 状态行
HTTP版本 响应码

>HTTP/2 200 
一个数字与文字组成的状态码，用来显示请求成功失败信息，如：Status Code: 200 OK

### 消息报头

响应头与请求头包含许多有用信息，例如：服务器类型、日期时间、内容类型和长度等。

##### Connection:keep-alive

（ 针对该连接所预期的选项） 保持连接状态

##### Content-Disposition:inline;filename=f.txt

（ 对已知MIME类型资源的描述，浏览器可以根据这个响应头决定是对返回资源的动作，如：将其下载或是打开。）

##### Content-Type:application/json;charset=UTF-8

（ 当前内容的MIME类型）表示实际发送的数据格式

##### Date:Wed, 07 Nov 2018 09:33:39 GMT*

（ 响应返回时间，此条消息被发送时的日期和时间(以RFC 7231中定义的"HTTP日期"格式来表示)）

##### Server:Tengine

（ 服务器的名称）服务器信息

##### Transfer-Encoding:chunked

（ 用表示实体传输给用户的编码形式。包括：chunked、compress、 deflate、gzip、identity。）分段传输数据方式（HTTP数据传输数据方式，运行服务器发送给客户端的数据可以分成多个部分， Content—length表示数据的长度，可以知道什么时候截数据）

##### Keep-Alive:timeout=5, max=96

 过期时间5s，max过了96s，强制断掉链接（max会自动减1，直到为0，会强制断掉链接）

##### Set-Cookie：
在客户端创建一个 Cookie

### 响应体

然后就是响应体的部分了，响应体就是服务器返回给客户端的文本信息。是我们发出请求之后需要得到的内容。

我们后面要测试接口，也是要根据拿到的响应体去进行一系列的断言，看看是否符合我们的预期。

刚才我们介绍过，接口响应的第一行有 HTTP 版本/响应码，接下来我们来介绍一些常见的响应码。

#### 1xx（临时响应）

表示临时响应并需要请求者继续执行操作的状态代码。一般是告诉客户端，请求已经收到了，正在处理，别急...

我们平常遇到这种响应状态码的时候很少。因为 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器是不可以向此类客户端发送 1xx 响应的。

#### 2XX (成功)

都表示服务器成功处理了请求的状态代码，说明网页可以正常访问。一般表示：请求收悉、我明白你要的、请求已受理、已经处理完成等信息。

- 200（成功） 找到了该资源，并且一切正常，服务器已成功处理了请求。

#### 3xx （重定向）

表示要完成请求，需要进一步操作。需要重定向到其它地方。它让客户端再发起一个请求以完成整个处理

- 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。

- 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

#### 4xx（请求错误）

这些状态代码表示请求可能出错，责任在客户端，如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等，妨碍了服务器的处理。

- 403 （禁止） 服务器拒绝请求。客户端未能获得授权。这通常是在401之后输入了不正确的用户名或密码。
- 404 （未找到） 服务器找不到请求的网页。在指定的位置不存在所申请的资源。

#### 5xx（服务器错误）

处理发生错误，责任在服务端，如服务端抛出异常，路由出错，HTTP版本不支持等

- 500 （服务器内部错误） 服务器遇到错误，无法完成请求。 看到这个错误，你就应该查查服务端的日志了，肯定抛出了一堆异常

- 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。

了解完常见的响应状态码，下面我们来了解一个概念。

## RESTful 架构

`Representational State Transfer`

借助于 HTTP 协议的基本请求方法代表资源的状态切换

- GET：获取资源
- POST：新增或者更新
- PUT：更新资源
- DELETE：删除资源
  
一个系统当中会有这么多的接口，如果接口之间的交互没有一套统一的规则，那么接口的形式就会非常的复杂，而且可维护性非常差。所以这时候我们就需要有一套标准的规则了。那我们现在在用的标准规则是什么呢？

现在其实大家都在遵守的就是 restful 架构。

大家前面已经学习过了 PO 设计模式，其实 restful 架构和 PO 设计模式是一个道理。restful 也是一个理念，是一个设计规范。他不是 http 之类的已经确定好的协议，而是一种规范。

Roy Thomas Fielding 博士于 2000 年在他的博士论文中提出来的一种万维网软件架构风格。其目的是为了便于不同的软件在网络中传递信息。

RESTful 是基于 HTTP 协议之上制定的一种资源请求、操作的风格，用一句话来概括就是使用 URL 去定位资源，使用 HTTP 动词描述操作。

遵守 REST 体系结构约束的 Web 服务 API 称为 RESTful API。

借助于 HTTP 协议的基本请求方法代表资源的状态切换。